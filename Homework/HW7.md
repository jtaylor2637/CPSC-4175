####  HW7
#### Jacob Taylor
#### CPSC 4175
#### 10/5/17

1) Testing should be done continuously throughout all of the phases of software creation, not just at the end of all the phases before delivery. Testing throughout allows designers, implementers, etc. to resolve many expensive issues quickly and reduce faults in the next phase.

2) Verification refers to determining whether a process has been correctly implemented. Validation means determining is the software does what it is supposed to do as shown in the specifications and design documents. Testing is composed of both of these terms, because they are both important to the quality of the software, however verification focuses more on code implementation and validation focuses more on design and analysis being followed correctly throughout the project.

3) Non-execution based testing is testing software without running test cases as implemented through code, examples include code review, and mathematical analysis of the code. Execution based testing is focused on test cases that are executed through the code, and determining if the output is correct for those cases.

4) Quality in software engineering is the extent of the software to satisfy its software specifications and requirements created by the client, the more requirements it satisfies the higher quality the product is.

5) Software should be tested by an independent group because they are more likely to find faults than the creators who may overlook some of their own mistakes, having fresh eyes allows for higher quality assurance. It also allows for neither group to overpower the other and allow for a decision to be made for each fault discovered.

6) Correctness proofs are mathematical analysis of the code that will also show whether the output would be correct in this code, the key differences are that correctness proofs has mathematical assertions at each line of the code to determine where in current execution the values are. Execution testing simply runs the code instead of analyzing it mathematically.

7) This article brings up many good points regarding software development. Oftentimes when writing a very large project we focus more on getting the deadline met rather than understanding the code. I know i have been personally guilty of this, and somehow gotten something to work, but not understand it. However I generally strive to understand my code as if I would have to explain it to another person. My experience with teaching programming has allowed me to be better at understanding the problem domain and solution as well.

8) I do not think there will be a software apocalypse, I believe there are many programmers and developers who are passionate and curious enough to actually solve and understand the problems they are tasked with. Personally I will continue to try and enhance my knowledge regarding my work in order to be able to reuse those same principles should I need to.