## Homework 01
### CPSC 4175
### Jacob Taylor
### 8/15/17

1. The four perceived components of the software crisis
are software being delivered late, over budget, with severe faults or bugs,
and not meeting the client's needs and expectations.

1. The software life cycle is different from the development
cycle in that the software life cycle starts at the creation
of the idea for the software and ends at the point where the
software is no longer needed or used, the life cycle typically
moves non-linearly and changes phases based on economic factors,
and design requirements. The development cycle tends to be more
consistent in that phases happen in a specific order, for instance
you wouldn't be able to jump from requirement analysis to testing
without first doing design and implementation.

1. Perfective maintenance typically refers to enhancements made to
a product or software which will create a easier or more intuitive user
experience. An example of this might be a person trying to use an inventory
management software for their business, the developer might add icons to the 
user interface to make actions more memorable, or create functionality for
a built in graph system to show the statistics of the transactions of that
company. Adaptive maintenance relates more to hardware changes or regulatory changes
created outside the software. An example might include a major construction company based in the US is
using software to determine the amount of materials in feet, pounds, etc. they will need
for their current project, if the US decided that they were switching to the metric
system and enforcing that change, all businesses would need to adapt to that change,
and therefore the developer of the software would need to implement a conversion system for
that software.

1. As hardware ages the components and materials begin to wear down from heat,
dust, and other issues. Eventually the hardware will become unusable and have faults,
which means the hardware must be replaced usually by something more powerful. Hardware also
cannot be updated like a software product can, if a change in hardware is needed the whole
component has to be replaced. Software is designed to improve as it gets older. It should
become more user-friendly, optimized, and have less errors in operation. Software may never be
fully complete as you cannot prove that it does not have unknown errors.

1. The meaning of having higher cost post-implementation means that software developers
should focus on routine maintenance at each step of the design phase, and should make
sure that all client requirements are met prior to delivery. This would reduce the 
overall cost of the project and help increase profitability, and also reduce unnecessary steps taken
to fix the issues after implementation.

1. Software engineering practices that want to avoid unnecessary costs and wasted time during
development use a continuous effort of planning, testing, and documentation all throughout the
development cycle of the software. Instead of using set out phases where each step occurs, it is better
to make sure that all specifications are met, code is tested, and every member of the team understands
the software plan during every change in implementation. Doing these routine checks ensures that the project 
is up to client desires, mostly fault free, and cost effective to produce.

1. Object oriented design still uses some of the classical design principles, such as implementation of attributes
and operation implementation. In order for the software to function correctly, the object must have some sort
of attributes to allow various data types and methods to be implemented. Likewise, the object must be able to carry out
operations such as transactions from a bank account has to update the bank account's balance after each transaction. While 
object oriented design seems to perform better than structured programming techniques, the two are not completely separable. 
The object design still needs analysis, testing, and implementation.

1. If the client and user are the same person then the interaction should be with that entity. However, if the client and users are
different entities, then the developers should interact with the client more often than the users, because the client may have a
different idea of the product compared to the users. The client is also the one who pays to have the software made, and in order to 
earn the revenue from the product, the client needs to be happy with the product.

1. One activity I could do each quarter, or annually, would be to start learning a new language, application, or software technique
that will make me a more competent computer scientist and a more valuable employee. Also participating in research would help me learn
more about my profession, and get publications under my name.

1. I believe this article brings up some good points regarding open source software. I've always thought that having your code be open source
could be dangerous, showing possible exploits to hackers, or releasing information that could help competitors. I never really considered
the positives that having a large user base available to critique and report errors could generate. I believe that deciding to make a project open
source really depends on the size of the project, team size, and team opinion. For instance, If I was developing a game myself, I probably would
never make it open source. However I do appreciate people who do create open source software for my learning benefit, so it is an interesting trade off.
The open source ability to create a polished product more quickly seems to be a high selling factor on it for consideration.
