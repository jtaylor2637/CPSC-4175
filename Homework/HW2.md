### Jacob Taylor
### CPSC 4175
### Homework 2
### 8/26/2017

1) The first step in creating a piece of software is determining the requirements that the software must accomplish.
This includes analysing the clients needs and specifications in order to create a design plan later.

2) Often times the clients' needs are different from what the client believes the software should do. The client may not realize there are underlying issues within the company that affects the current project being designed. The difference lies in that you can ask the client what they believe they need, but you have to analyse the client's situation and domain in order to see what functions they software should do and how it does it.

3) A software engineer may not always be extremely knowledgeable in a specific field outside of computing and development, and it would be difficult to obtain a deep understanding of every domain the developer works in for the contracted clients, such as banking, medical, construction etcetera . The software engineer tends to have the general knowledge of many fields, and creates glossaries and other documents in order to assist him when communicating to the client about the specifications of the project. 

4) Some ways of determining requirements is to interview with the clients in order to obtain a deeper understanding about both the business model of the client, as well as understanding how the problem affects them. One reason this may not be effective is that the interview is unstructured and does not yield detailed or useful results, and also that conducting a successful interview is not an easy task due to the nature of extracting useful information. Another way is to use direct observation through video tapes, this allows the developer to watch the process of the clients and analyse the problems they are experiencing. An issue with this method is that it requires significant time to analyse, and also can be viewed as an invasion of privacy by the workers being recorded.

5) Requirements are dynamic in that they are always changing based on observed needs, or the client changing their minds about functionality and priority. The opinions of the developers, clients, and users can all affect the status of the requirements at any point. Therefore, they are not a static list that never needs to be reviewed.

6) Functional requirements are typically more known to the developers during initial planning and implementation phases. They are the goals that have to be met according to the requirements specifications set by the client and developer.
Non-functional requirements tend to be a underlying functionality that exists to make the program more efficient, such as the layout of the user interface, loading times, and how much maintenance will be performed on the software.

7) Top-down analysis refers to the method of software development in which the entire software is planned and designed intensely prior to any form of implementation. This allows the development team to ensure the software will be designed
appropriately to the specifications of the client, as well as creating a product that is effective at its functionality. The case study in chapter 11 implements case models each time they learn more about the company rather than obtaining as much information at one time.

8) Rapid prototyping may seem harmful because it focuses too much on rapid changes in development rather than analysing the requirements for a more useful design. It may also give the clients a false sense of how the final product will work, as well as inaccurate feedback during client prototype testing due to errors or developer choices.

9) I believe Team Two is doing a better job because they are more likely to be communicating with their clients and users of the product more frequently than Team One since they make frequent changes to the requirements specification. Requirements are dynamic and should change fairly often.

10) I believe this is true because if the developer believes the requirement means implement this feature, and the client wanted something completely different, then the product will have a fault in functionality. This may lead to a quick attempt to fix the error by the developer after the client notifies him, which may lead to problems with other parts of the code that were originally designed for the wrong requirement's implementation.
